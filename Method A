import pandas as pd
import re
from rapidfuzz import fuzz
import json
import os
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("similarity_calculator.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ProductSimilarity")

def calculate_similarity(input_data, config_path=None, debug=False, sppp=None):
    """
    商品名称相似度计算主函数（兼容RPA调用）
    
    参数:
        input_data: 输入数据，应为包含两个元素的列表（如[文本1, 文本2]）
        config_path: 配置文件路径，默认为None
        debug: 是否开启调试模式，开启后会输出详细日志
        sppp: 从数据库导入的品牌映射字典，格式为{'品牌别名': '标准品牌名'}
    
    返回:
        相似度分数（0-1之间的浮点数）
    """
    try:
        # 初始化计算器（传入sppp）
        calculator = ProductSimilarityCalculator(config_path, debug, sppp)
        
        # 处理输入数据（确保为一对文本）
        if isinstance(input_data, list) and len(input_data) == 2:
            # 提取两个文本（转为字符串处理）
            str1 = str(input_data[0]).strip() if input_data[0] is not None else ""
            str2 = str(input_data[1]).strip() if input_data[1] is not None else ""
        else:
            logger.error(f"输入数据格式错误，需为包含两个元素的列表，实际为: {type(input_data)}")
            raise TypeError("输入数据必须是包含两个文本的列表（如[文本1, 文本2]）")
        
        # 计算单对文本的相似度
        similarity = calculator._calculate_pair_similarity(str1, str2)
        return similarity  # 返回单个浮点数
    
    except Exception as e:
        logger.error(f"相似度计算失败: {str(e)}", exc_info=True)
        return 0.0  # 异常时返回默认值

class ProductSimilarityCalculator:
    """通用商品名称相似度计算工具"""
    
    def __init__(self, config_path=None, debug=False, sppp=None):
        """初始化计算器"""
        self.debug = debug
        self.config = self._load_config(config_path, sppp)  # 传入sppp
        self._validate_config()
        
        # 从配置中提取参数
        self.brand_mapping = self.config.get("brand_mapping", {})
        self.synonyms = self.config.get("synonyms", {})
        self.stop_words = self.config.get("stop_words", [])
        self.feature_weights = self.config.get("feature_weights", {})
        self.min_similarity = self.config.get("min_similarity", {})
        self.color_words = self.config.get("color_words", [])
        self.extended_brands = self.config.get("extended_brands", [])
        
        # 标准化配置（确保大小写一致）
        self.brand_mapping = {k.lower(): v.lower() for k, v in self.brand_mapping.items()}
        self.synonyms = {k.lower(): [v.lower() for v in vs] for k, vs in self.synonyms.items()}
        self.stop_words = [w.lower() for w in self.stop_words]
        self.color_words = [c.lower() for c in self.color_words]
        self.extended_brands = [b.lower() for b in self.extended_brands]
        
        if self.debug:
            logger.info(f"配置加载完成: {self.config}")
    
    def _load_config(self, config_path, sppp=None):
        """加载配置文件（增加sppp参数）"""
        # 默认配置
        default_config = {
            "brand_mapping": {
                "iphone": "苹果",
                "ipad": "苹果",
                "macbook": "苹果",
                "galaxy": "三星",
                "surface": "微软",
                "airpods": "苹果",
                "huawei": "华为",
                "honor": "荣耀",
                "xiaomi": "小米",
                "lenovo": "联想",
                "dell": "戴尔",
                "meituan": "美团",
                "ele": "饿了么",
                "starbucks": "星巴克",
                "kfc": "肯德基",
                "mcdonalds": "麦当劳",
                "disney": "迪士尼",
                "nike": "耐克",
                "adidas": "阿迪达斯",
                "chanel": "香奈儿",
                "coca-cola": "可口可乐",
                "tesla": "特斯拉",
                "dji": "大疆",
                "nintendo": "任天堂",
                "sony": "索尼",
                "microsoft": "微软",
                "gree": "格力",
                "philips": "飞利浦",
                "lego": "乐高",
                "haier": "海尔",
                "samsung": "三星",
                "canon": "佳能",
                "loreal": "欧莱雅",
                "mengniu": "蒙牛",
                "kingston": "金士顿"
            },
            "synonyms": {
                "pro": ["专业版", "pro版", "professional"],
                "max": ["max版", "超大杯", "maximum"],
                "ml": ["毫升"],
                "g": ["克"],
                "gb": ["g", "吉字节"],
                "盒": ["箱", "包装"],
                "听": ["罐"],
                "电竞": ["游戏", "gaming"],
                "智能": ["智慧", "smart"],
                "笔记本": ["笔记本电脑", "laptop"],
                "手机": ["智能手机", "移动电话"],
                "空调": ["冷气机"],
                "相机": ["照相机", "摄像机"],
                "英寸": ["寸"],
                "升": ["l"],
                "匹": ["p"],
                "国行": ["大陆版", "国行版"],
                "港版": ["香港版", "港版"],
                "日版": ["日本版"],
                "双开门": ["对开门"],
                "无线": ["蓝牙", "wifi"],
                "高清": ["4k", "ultra hd"],
                "充电": ["快充", "无线充电"]
            },
            "stop_words": [
                "的", "了", "和", "是", "在", "我", "有", "要", "就", "不", "人", "都", 
                "款", "式", "系列", "装", "版", "型", "号", "限定", "限定款", "经典款", 
                "正品", "行货", "水货", "原装", "全新", "二手", "港版", "国行"
            ],
            "feature_weights": {
                "brand": 0.4,
                "model": 0.35,
                "specs": 0.15,
                "keywords": 0.05,
                "digits": 0.03,
                "color": 0.02
            },
            "min_similarity": {
                "brand_match": 0.7,
                "model_match": 0.8
            },
            "color_words": [
                "红", "蓝", "黑", "白", "灰", "金", "银", "紫", "绿", "粉", "黄", "橙", "棕", "青", 
                "深空灰", "远峰蓝", "星光色", "曜石黑", "陶瓷白", "玫瑰金"
            ],
            "extended_brands": [
                "Pro", "Max", "Mini", "Ultra", "Plus", "Lite", "Premium", 
                "Note", "S", "SE", "Air", "Book", "Pad", "Phone", "Watch"
            ]
        }
        
        # 合并数据库品牌映射
        if sppp and isinstance(sppp, dict):
            # 更新默认品牌映射
            default_config["brand_mapping"].update(sppp)
            if self.debug:
                logger.info(f"已合并数据库品牌映射: {len(sppp)}条记录")
        
        # 加载自定义配置
        if config_path and os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    custom_config = json.load(f)
                # 合并默认配置和自定义配置
                default_config.update(custom_config)
                if self.debug:
                    logger.info(f"已加载自定义配置: {config_path}")
            except Exception as e:
                logger.error(f"加载自定义配置失败: {str(e)}")
        
        return default_config
    
    def _validate_config(self):
        """验证配置的有效性"""
        # 验证特征权重总和为1
        weights = self.config.get("feature_weights", {})
        if weights:
            total = sum(weights.values())
            if abs(total - 1.0) > 0.01:
                logger.warning(f"特征权重总和不为1: {total}, 已自动归一化")
                self.config["feature_weights"] = {k: v/total for k, v in weights.items()}
    
    def preprocess_text(self, text):
        """文本预处理"""
        if not isinstance(text, str) or not text.strip():
            return ""
        
        try:
            # 转换为小写并去除首尾空格
            text = text.lower().strip()
            
            # 统一特殊字符
            text = re.sub(r'[*/×x&（）【】、，。！？；："“”‘’\-_]', ' ', text)
            
            # 品牌缩写替换
            for abbr, brand in self.brand_mapping.items():
                # 使用正则表达式匹配完整单词，避免部分匹配
                text = re.sub(rf'\b{re.escape(abbr)}\b', brand.lower(), text)
            
            # 同义词替换
            for syn, words in self.synonyms.items():
                for word in words:
                    text = re.sub(rf'\b{re.escape(word.lower())}\b', syn.lower(), text)
            
            # 数字单位标准化
            text = re.sub(r'(\d+)\s*(gb|g)\b', r'\1gb', text)
            text = re.sub(r'(\d+)\s*(ml|毫升)\b', r'\1ml', text)
            text = re.sub(r'(\d+)\s*(升|l)\b', r'\1l', text)
            text = re.sub(r'(\d+)\s*(寸|英寸)\b', r'\1英寸', text)
            text = re.sub(r'(\d+)\s*(匹|p)\b', r'\1匹', text)
            
            # 移除停用词
            for word in self.stop_words:
                text = re.sub(rf'\b{re.escape(word)}\b', '', text)
            
            # 合并多个空格为单个空格
            text = re.sub(r'\s+', ' ', text).strip()
            
            return text
        except Exception as e:
            logger.error(f"文本预处理出错: {str(e)}", exc_info=True)
            return ""
    
    def extract_features(self, text):
        """提取文本特征"""
        features = {
            "brand": "",
            "model": "",
            "specs": [],
            "keywords": [],
            "digits": "",
            "color": ""
        }
        
        if not text:
            return features
        
        try:
            # 品牌识别
            features["brand"] = self._extract_brand(text)
            
            # 型号提取
            features["model"] = self._extract_model(text, features["brand"])
            
            # 规格提取
            features["specs"] = self._extract_specs(text)
            
            # 关键词提取
            features["keywords"] = self._extract_keywords(text, features["brand"], features["model"])
            
            # 数字特征
            digits = re.findall(r'\d+', text)
            features["digits"] = ''.join(digits)
            
            # 颜色提取
            features["color"] = self._extract_color(text)
            
            if self.debug:
                logger.debug(f"文本: {text}, 提取特征: {features}")
                
            return features
        except Exception as e:
            logger.error(f"特征提取出错: {str(e)}", exc_info=True)
            return features
    
    def _extract_brand(self, text):
        """提取品牌"""
        # 检查品牌映射
        for abbr, brand in self.brand_mapping.items():
            if abbr.lower() in text.lower():
                return brand.lower()
        
        # 检查扩展品牌
        for brand in self.extended_brands:
            if brand.lower() in text.lower():
                return brand.lower()
        
        # 尝试从文本中提取可能的品牌
        # 提取2-4个字符的英文单词
        potential_brands = re.findall(r'\b[a-zA-Z]{2,4}\b', text)
        if potential_brands:
            return potential_brands[0].lower()
        
        return ""
    
    def _extract_model(self, text, brand):
        """提取型号"""
        if not text:
            return ""
        
        # 移除品牌信息
        if brand:
            text = re.sub(rf'\b{re.escape(brand)}\b', '', text).strip()
        
        # 型号提取正则（字母+数字组合）
        model_patterns = [
            r'([a-zA-Z]{2,}[\s-]*\d+[a-zA-Z0-9]*)',  # 如iPhone 15 Pro
            r'([a-zA-Z]+\d+[a-zA-Z]*)',                # 如M2、S24
            r'(\d+[a-zA-Z]+)',                          # 如15 Pro、500L
            r'([a-zA-Z]{3,})'                           # 如Ultra、Max
        ]
        
        model = ""
        for pattern in model_patterns:
            match = re.search(pattern, text)
            if match:
                model = re.sub(r'\s+', '', match.group(1)).lower()
                break
        
        # 如果型号与品牌相同，视为无效
        if model.lower() == brand.lower():
            model = ""
            
        return model
    
    def _extract_specs(self, text):
        """提取规格"""
        # 匹配数字+单位的组合
        specs = re.findall(
            r'(\d+(?:\.\d+)?\s*(?:gb|ml|l|英寸|匹|套|片|g|kg|cm|mm))', 
            text
        )
        # 移除空格并转换为小写
        return [re.sub(r'\s+', '', spec).lower() for spec in specs]
    
    def _extract_keywords(self, text, brand, model):
        """提取关键词"""
        if not text:
            return []
        
        # 移除品牌和型号
        if brand:
            text = re.sub(rf'\b{re.escape(brand)}\b', '', text)
        if model:
            text = re.sub(rf'\b{re.escape(model)}\b', '', text)
        
        # 提取中文关键词（2字以上）
        chinese_words = re.findall(r'[\u4e00-\u9fa5]{2,}', text)
        
        # 提取英文关键词（3字母以上）
        english_words = re.findall(r'[a-zA-Z]{3,}', text)
        
        # 过滤停用词和数字
        all_words = chinese_words + english_words
        keywords = [
            word for word in all_words 
            if word.lower() not in self.stop_words and not word.isdigit()
        ]
        
        return keywords
    
    def _extract_color(self, text):
        """提取颜色"""
        if not text:
            return ""
        
        # 检查颜色词
        for color in self.color_words:
            if color.lower() in text.lower():
                return color.lower()
        
        return ""
    
    def calculate_feature_similarity(self, features1, features2):
        """计算特征相似度"""
        if not features1 or not features2:
            return 0.0
        
        try:
            # 1. 品牌相似度
            brand_sim = self._calculate_brand_similarity(features1["brand"], features2["brand"])
            
            # 2. 型号相似度
            model_sim = self._calculate_model_similarity(features1["model"], features2["model"])
            
            # 3. 规格相似度
            spec_sim = self._calculate_specs_similarity(features1["specs"], features2["specs"])
            
            # 4. 关键词相似度
            keyword_sim = self._calculate_keywords_similarity(features1["keywords"], features2["keywords"])
            
            # 5. 数字相似度
            digit_sim = self._calculate_digits_similarity(features1["digits"], features2["digits"])
            
            # 6. 颜色相似度
            color_sim = self._calculate_color_similarity(features1["color"], features2["color"])
            
            # 动态加权
            weights = self.feature_weights
            total_sim = (
                weights["brand"] * brand_sim +
                weights["model"] * model_sim +
                weights["specs"] * spec_sim +
                weights["keywords"] * keyword_sim +
                weights["digits"] * digit_sim +
                weights["color"] * color_sim
            )
            
            # 应用提升规则
            if brand_sim > 0.8 and model_sim > 0.7:
                total_sim = max(total_sim, self.min_similarity.get("model_match", 0.8))
            elif brand_sim > 0.8:
                total_sim = max(total_sim, self.min_similarity.get("brand_match", 0.7))
            
            if self.debug:
                logger.debug(f"特征相似度计算: {features1} vs {features2} = {total_sim}")
                
            return min(max(total_sim, 0.0), 1.0)
        except Exception as e:
            logger.error(f"相似度计算出错: {str(e)}", exc_info=True)
            return 0.0
    
    def _calculate_brand_similarity(self, brand1, brand2):
        """计算品牌相似度"""
        if not brand1 and not brand2:
            return 0.5  # 都无品牌，视为部分相似
        if not brand1 or not brand2:
            return 0.3  # 只有一个有品牌，视为低相似
        if brand1 == brand2:
            return 1.0  # 品牌完全匹配
        if brand1 in brand2 or brand2 in brand1:
            return 0.8  # 品牌部分匹配
        return fuzz.partial_ratio(brand1, brand2) / 100.0  # 模糊匹配
    
    def _calculate_model_similarity(self, model1, model2):
        """计算型号相似度"""
        if not model1 and not model2:
            return 0.5  # 都无型号，视为部分相似
        if not model1 or not model2:
            return 0.3  # 只有一个有型号，视为低相似
        
        # 提取型号中的数字部分
        digits1 = re.findall(r'\d+', model1)
        digits2 = re.findall(r'\d+', model2)
        
        # 数字匹配（更重要）
        digit_match = 1.0 if digits1 == digits2 else (
            0.8 if digits1 and digits2 and (digits1[0] == digits2[0]) else 0.0
        )
        
        # 词序无关匹配
        model_sim = max(
            fuzz.token_set_ratio(model1, model2),
            fuzz.partial_ratio(model1, model2)
        ) / 100.0
        
        # 数字匹配占60%权重，字符串匹配占40%权重
        return model_sim * 0.4 + digit_match * 0.6
    
    def _calculate_specs_similarity(self, specs1, specs2):
        """计算规格相似度"""
        if not specs1 and not specs2:
            return 0.5  # 都无规格，视为部分相似
        
        # 提取规格中的数字部分
        spec_digits1 = ''.join(re.findall(r'\d+', ''.join(specs1)))
        spec_digits2 = ''.join(re.findall(r'\d+', ''.join(specs2)))
        
        # 数字匹配
        digit_match = 1.0 if spec_digits1 == spec_digits2 else (
            0.8 if spec_digits1 and spec_digits2 and (spec_digits1 in spec_digits2 or spec_digits2 in spec_digits1) else 0.0
        )
        
        # 规格集合相似度
        spec_sim = len(set(specs1) & set(specs2)) / len(set(specs1) | set(specs2)) if specs1 or specs2 else 0.5
        
        # 数字匹配占70%权重，集合相似度占30%权重
        return spec_sim * 0.3 + digit_match * 0.7
    
    def _calculate_keywords_similarity(self, keywords1, keywords2):
        """计算关键词相似度"""
        if not keywords1 and not keywords2:
            return 0.5  # 都无关键词，视为部分相似
        
        # 关键词集合相似度
        return len(set(keywords1) & set(keywords2)) / len(set(keywords1) | set(keywords2)) if keywords1 or keywords2 else 0.5
    
    def _calculate_digits_similarity(self, digits1, digits2):
        """计算数字相似度"""
        if not digits1 and not digits2:
            return 0.5  # 都无数字，视为部分相似
        if digits1 == digits2:
            return 1.0  # 数字完全匹配
        if digits1 in digits2 or digits2 in digits1:
            return 0.7  # 数字部分匹配
        
        # 计算最长公共子序列
        lcs = self.longest_common_subsequence(digits1, digits2)
        return len(lcs) / max(len(digits1), len(digits2)) if digits1 and digits2 else 0.0
    
    def _calculate_color_similarity(self, color1, color2):
        """计算颜色相似度"""
        return 1.0 if color1 == color2 else 0.0
    
    def _calculate_pair_similarity(self, str1, str2):
        """计算一对商品名称的相似度"""
        if not str1.strip() or not str2.strip():
            return 0.0
        
        # 预处理
        str1_clean = self.preprocess_text(str1)
        str2_clean = self.preprocess_text(str2)
        
        if self.debug:
            logger.debug(f"原始文本1: {str1}")
            logger.debug(f"预处理后1: {str1_clean}")
            logger.debug(f"原始文本2: {str2}")
            logger.debug(f"预处理后2: {str2_clean}")
        
        # 特征提取
        features1 = self.extract_features(str1_clean)
        features2 = self.extract_features(str2_clean)
        
        # 计算特征相似度
        feature_sim = self.calculate_feature_similarity(features1, features2)
        
        # 文本相似度补充（仅当特征相似度在特定范围时）
        text_sim = 0.0
        if 0.3 < feature_sim < 0.7:
            text_sim = fuzz.token_set_ratio(str1_clean, str2_clean) / 100.0
        
        # 最终相似度（特征相似度占90%，文本相似度占10%）
        final_sim = feature_sim * 0.9 + text_sim * 0.1
        
        if self.debug:
            logger.debug(f"最终相似度: {final_sim} (特征相似度: {feature_sim}, 文本相似度: {text_sim})")
        
        return round(final_sim, 4)
    
    def longest_common_subsequence(self, s1, s2):
        """计算最长公共子序列"""
        m, n = len(s1), len(s2)
        if m == 0 or n == 0:
            return ""
        
        # 动态规划表
        dp = [[""] * (n + 1) for _ in range(2)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[1][j] = dp[0][j - 1] + s1[i - 1]
                else:
                    dp[1][j] = max(dp[0][j], dp[1][j - 1], key=len)
            # 滚动数组优化空间复杂度
            dp[0] = dp[1][:]
            dp[1] = [""] * (n + 1)
        
        return dp[0][n]
